<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>libmorpho: Technical details</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="main.html">libmorpho Documentation</a></div>
<h1><a class="anchor" name="detailsPage">Technical details</a></h1><h2><a class="anchor" name="sectionWhat">
What is implemented?</a></h2>
libmorpho provides algorithms for morphological erosions, dilations, openings, and closings. All the implementations are based on ideas presented in the following two papers:<p>
<ul>
<li>M. Van Droogenbroeck and M. Buckley. <b>Morphological erosions and openings: fast algorithms based on anchors</b>. <em>Journal of Mathematical Imaging and Vision</em>, Special Issue on Mathematical Morphology after 40 Years, 22(2-3):121-142, May 2005.</li><li>M. Van Droogenbroeck and H. Talbot. <b>Fast Computation of morphological operations with arbitrary structuring elements</b>. <em>Pattern Recognition Letters</em>, 17(14):1451-1460, 1996.</li></ul>
<p>
The first paper presents an algorithm for linear structuring elements. From our experience, for sizes larger than 3-4 pixels, these algorithms are faster than van Herk's algorithms. The second paper describes an algorithm applicable to arbitrary shaped structuring elements. In addition, you can use a structuring function instead of a structuring element (sometimes called <em>flat</em> structuring element).<h2><a class="anchor" name="sectionPerf">
A few words of theory</a></h2>
According to Steiner, a square S can be decomposed as the dilation of an horizontal segment H by a vertical segment:<p>
<div class="fragment"><pre class="fragment"> S = H + V
</pre></div><p>
The chain rule helps us then to reduce the computation time as it states that the erosion of an image f by a square S is equivalent to two successive erosions. More precisely,<p>
<div class="fragment"><pre class="fragment"> f - S = f - (H + V) = (f - H) - V
</pre></div><p>
The same applies to dilations and therefore an opening by a square can be computed as 4 successive erosions or dilations:<p>
<div class="fragment"><pre class="fragment"> f o S = f o (H + V) = [([f - H] -V) + H] + V
</pre></div><p>
This expression is the key property for most implementations. However one of the abovementioned paper and other papers have proposed algorithms that implements openings directly. To our knowledge all these implementations applies only to operations with one-dimensional structuring elements. The following figure compares the computation times of several known algorithms:<p>
<center> <div align="center">
<img src="graph.jpg" alt="graph.jpg">
</div>
<br>
<b>Computation times with a linear structuring element</b> </center><p>
On this graph one can see that the computation time of an opening is slightly lower than the computation time of an erosion. We can take profit of this observation and, if one remember that the dilation is commutative, implement openings by squares as<p>
<div class="fragment"><pre class="fragment"> f o S = f o (H + V) = [([f - H] -V) + V] + H = ([f - H] o V) + H
</pre></div><p>
Two-dimensional openings and closings provided in this library have been implemented in this way.<p>
Please remember that (foH)oV is not equal to (foS). In fact (foH)oV is not even an opening, but the supremum of (foH) and (foV) is an opening.<h3><a class="anchor" name="sizeTest">
Discussions on the size of the structuring element</a></h3>
Theory tells us that erosion and dilation depends on the location of the origin, but not openings and closings. This has a practical consequence. Let us take a simple structuring element like a 2x2 square. Where should one locate the origin? Obviously all the corners are valid candidates. With a 3x3 square you won't have to handle this king of issue. The usual workaround is to force structuring elements to have odd dimensions. We proceeded likewise for erosions and dilations in libmorpho. <br>
<p>
But there is no reason to impose this workaround for openings and closings as long as we do not compute openings and closings directly (not as the cascade of an erosion followed by a dilation or vice versa). In libmorpho, horizontal and vertical one-dimensional openings and closings (<a class="el" href="group__libmorpho_g8a3f6df2670b99d24fb49e8e4aa7e469.html#g8a3f6df2670b99d24fb49e8e4aa7e469">openingByAnchor_1D_horizontal</a>, <a class="el" href="group__libmorpho_gc02601badcb4f3e5cfae039d604bac3f.html#gc02601badcb4f3e5cfae039d604bac3f">openingByAnchor_1D_vertical</a>, <a class="el" href="group__libmorpho_g8eb54c6cfee261402641928d731b80e3.html#g8eb54c6cfee261402641928d731b80e3">closingByAnchor_1D_horizontal</a>, and <a class="el" href="group__libmorpho_geb5fcd6ff71a59e004674d1670440bd1.html#geb5fcd6ff71a59e004674d1670440bd1">closingByAnchor_1D_vertical</a>) are not limited to structuring elements with odd sizes; this particularity is not usual with other libraries dedicated to mathematical morphology.<h3><a class="anchor" name="subArbitrary">
Arbitrary shaped structuring elements and functions</a></h3>
Morphology with arbitrary shaped structuring elements proved hard to be implemented. The main reason is that with most shapes there is no possible simplification like the chain rule. Our implementation uses a sliding histogram that is moved step by step around the original image. As we allow an arbitrary shaped structuring element we can use lines or rectangles with even sizes, even for the case of erosions and dilations. In <a class="el" href="group__libmorpho_g3a992a646187a1ab2c52bf8d2e4cf2eb.html#g3a992a646187a1ab2c52bf8d2e4cf2eb">erosion_arbitrary_SE</a> you can see that the structuring element is provided as an image. To describe the structuring element we use the following convention to fill that image:<p>
<ul>
<li>0 means that this pixel does not belong to the structuring element</li><li>1 means that this pixel belongs to the structuring element</li></ul>
<p>
When the image value is larger than 1, for example 5, then it is assumed that you have defined a structuring function and that 4 (=5-1) is the value of the structuring function. Also you have to provide the location the origin. In our implementations the structuring element must contain the origin (i.e. its value in the image should be larger or equal to 1).<h3><a class="anchor" name="sectionBorder">
Border effects</a></h3>
When the origin of the structuring element coincides with a pixel close to the border, part of the structuring element covers areas located outside the image. This problem is generally referred to as <em>border effects</em>.<p>
We discussed border effects in depth under the framework of <em>domain-invariance</em> in one of the abovementioned papers. The general conclusion is that border effects for an opening differ when the opening is computed as the cascade of an erosion and a dilation or when the opening is computed directly. For this reason you may find out that <div class="fragment"><pre class="fragment"> f o S = ([f - H] o V) + H
</pre></div> does not provide the same results as <div class="fragment"><pre class="fragment"> f o S = [([f - H] -V) + H] + V
</pre></div> on the top and bottom areas of the image. This is not a bug of our implementation (but there might be other bugs...).<h3><a class="anchor" name="sectionBuffer">
Memory accesses in C</a></h3>
As for any algorithms written in C we had to deal with the issue of memory access. Two-dimensional buffers are stored as vectors. It proves to be faster to access a neighbouring pixel than a pixel located a raw below. This is why the implementation with an horizontal line is faster than with a vertical line (see <a class="el" href="performancesPage.html#erosionTimes">Computation times for 1000 erosions</a>). Although libmorpho implements vertical operations directly you may be tempted to compute a vertical operations as a horizontal operations after and before transposing the image. From our experience this is slower than the direct implementations with a vertical segment but you can make your own mind by trying it with or whithout the <a class="el" href="group__libmorpho_ge504c5c43a3a4f814e6b2fe35f906736.html#ge504c5c43a3a4f814e6b2fe35f906736">imageTranspose</a> function provided in this package.<p>
A ranking of different operators is provided in section <a class="el" href="performancesPage.html#rankingTimes">Relative ranking [Computation times for 1000 operations]</a>. <hr>
<a href="http://www.ulg.ac.be/telecom/">Telecommunications and Imaging Laboratory</a> - 
<a href="http://www.montefiore.ulg.ac.be">Institut Montefiore</a> - 
<a href="http://www.ulg.ac.be">Universit&eacute; de Li&egrave;ge</a>
